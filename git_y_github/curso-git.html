<head>CURSO GIT Y GIT HUB</head>
<h2>Segundo módulo</h2>
<body>
<h1>CLASE 9</h1>
<h3>vim -> esc + i:</h3>
<p>puedo escribir en el editor de txt de la consola
esc + shift + zz <- guardar -> esc + :wq! 
suelo entrar acá cuando hago un commit sin mensaje</p>

<h3>git show</h3>
<p>para visualizar el ultimo cambio desde la version anterior a la actual</p>
<h3>git log</h3>
<p>para ver todos los commit</p>

<h3>git diff</h3> <p>(+ indicador del commit -espacio- identificador commit que comparo)
para visualizar los cambios entre las versiones comparadas</p>
___________________________________________________
<h1>CLASE 10</h1>
<h3>git rm --cached</h3> <p>(elimino lo que agregué al staging - cuando hago add)</p>
<h3>git rm --force</h3> <p>(elimino los archivos de git y del disco duro)</p>

<strong> <b>rastrear:</b> antes de trackear los archivos (con git add)
<b>stagin:</b> memoria ram (estado temporal)
<b>repositorio real:</b> al que llego cuando hago un commit
</strong>
<h3>git checkout</h3><p> -> para traerme los archivos del repositorio a mi trabajo local
</p>
___________________________________________________
<h1>CLASE 11 RAMAS (la principal es main)</h1>
<p>
<strong> 
hotfix (arreglo en caliente)-> cuando encuentro un bug en las versiones que pruebo, y hago un git merge para unir con la rama principal
development -> cuando hago experimentos en el codigo
main (master)-> la rama principal del trabajo</strong></p>

____________________________________________________
<h1>CLASE 12</h1>
<h3> reset (+ indicador de commit)</h3>
<p> <- es como volver en el tiempo
se elimina del staging los ultimos cambios y me regresa al commit que indicamos (se pierde todo lo anterior)
</p>

<h3>git reset soft</h3><p> (+ indicador de commit)
lo mismo pero no pierdo del staging el ultimo git add que había hecho
</p>

<h3>git log --stat</h3>
<p>puedo ver los cambios especificos en cada commit
para ver cómo era el archivo en un commit anterior (en mi directorio de trabajo)
<b>git checkout (+ identificador del commit que quiero traer + qué archivo quiero de regreso)</b><br>
=> mi repositorio actual se va a actualizar para quedar como en el commit solicitado. <br>
(!!!)si yo hago un commit, voy a perder todo lo progresado
(!!!)esto me lo avisa cuando hago un git status<br>
=> para volver al archivo en el último cambio, pido el de master: 
<b>git checkout master (+ nombre de archivo)</b></p>
___________________________________________________
<h1>CLASE 13</h1>
<h3>git reset HEAD:</h3><p> para sacar archivos del área de staging.
No los borra, solo que los últimos cambios de estos archivos
no se envían al último commit, a menos que los REincluya con git add, por supuesto.
</p></body>

<h4>Aporte creado por: Juan David Castro</h4><body>
 <h1>Git reset y git rm son comandos con utilidades muy diferentes, pero se pueden confundir muy fácilmente.</h1>

<h3>git rm</h3>
Este comando nos ayuda a eliminar archivos de Git sin eliminar su historial del sistema de versiones. Esto quiere decir que si necesitamos recuperar el archivo solo debemos “viajar en el tiempo” y recuperar el último commit antes de borrar el archivo en cuestión.

Recuerda que git rm no puede usarse así nomás. Debemos usar uno de los flags para indicarle a Git cómo eliminar los archivos que ya no necesitamos en la última versión del proyecto:

<h3>git rm --cached:</h3> Elimina los archivos de nuestro repositorio local y del área de staging, pero los mantiene en nuestro disco duro. Básicamente le dice a Git que deje de trackear el historial de cambios de estos archivos, por lo que pasaran a un estado untracked.
<h3>git rm --force:</h3> Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al registro de la existencia de los archivos, de modo que podremos recuperarlos si es necesario (pero debemos usar comandos más avanzados).
<h3>git reset</h3>
Este comando nos ayuda a volver en el tiempo. Pero no como git checkout que nos deja ir, mirar, pasear y volver. Con git reset volvemos al pasado sin la posibilidad de volver al futuro. Borramos la historia y la debemos sobreescribir. No hay vuelta atrás.

Este comando es muy peligroso y debemos emplearlo solo en caso de emergencia. Recuerda que debemos usar alguna de estas dos opciones:

Hay dos formas de utilizar git reset: con el argumento --hard, borrando toda la información que tengamos en el área de staging (y perdiendo todo para siempre). O, un poco más seguro, con el argumento --soft, que mantiene allí los archivos del área de staging para que podamos aplicar nuestros últimos cambios pero desde un commit anterior.

<h3>git reset --soft:</h3> Borramos todo el historial y los registros de Git pero guardamos los cambios que tengamos en Staging, así podemos aplicar las últimas actualizaciones a un nuevo commit.
<h3>git reset --hard:</h3> Borra todo. Todo todito, absolutamente todo. Toda la información de los commits y del área de staging se borra del historial.
¡Pero todavía falta algo!

<h3>git reset HEAD:</h3> Este es el comando para sacar archivos del área de staging. No para borrarlos ni nada de eso, solo para que los últimos cambios de estos archivos no se envíen al último commit, a menos que cambiemos de opinión y los incluyamos de nuevo en staging con git add, por supuesto.
<h3>¿Por qué esto es importante?</h3>
Imagina el siguiente caso:

Hacemos cambios en los archivos de un proyecto para una nueva actualización. Todos los archivos con cambios se mueven al área de staging con el comando git add. Pero te das cuenta de que uno de esos archivos no está listo todavía. Actualizaste el archivo, pero ese cambio no debe ir en el próximo commit por ahora.

¿Qué podemos hacer?

Bueno, todos los cambios están en el área de Staging, incluido el archivo con los cambios que no están listos. Esto significa que debemos sacar ese archivo de Staging para poder hacer commit de todos los demás.

¡Al usar git rm lo que haremos será eliminar este archivo completamente de git! Todavía tendremos el historial de cambios de este archivo, con la eliminación del archivo como su última actualización. Recuerda que en este caso no buscábamos eliminar un archivo, solo dejarlo como estaba y actualizarlo después, no en este commit.

En cambio, si usamos git reset HEAD, lo único que haremos será mover estos cambios de Staging a Unstaged. Seguiremos teniendo los últimos cambios del archivo, el repositorio mantendrá el archivo (no con sus últimos cambios, pero sí con los últimos en los que hicimos commit) y no habremos perdido nada.

Conclusión: Lo mejor que puedes hacer para salvar tu puesto y evitar un incendio en tu trabajo es conocer muy bien la diferencia y los riesgos de todos los comandos de Git.


</body>
___________________________________________________
<h2>Tercer módulo</h2>
<body>
    <h1>CLASE 14</h1>
    <p>
        en el repositorio que estoy usando hago un <b>git init</b>
        => aparece el <b>staging</b> (repositorio local al cual accedo cuando hago <b>git add</b>)
        => cuando hago <b>git commit</b> envío lo que queda en staging al <b>repositorio local</b><br>
        entonces cuando hago git init voy a tener (en mi entorno de desarrollo personal):<br>
         1) directorio de trabajo <br>
         2) staging (llego con git add)<br>
         3) repositorio local (llego con git commit)<br>
         <br>
         por ultimo, necesito un repositorio remoto, que es donde puedo tambien trabajar con otras personas
        => para eso tengo que hacer <b>git clone <i>+url</i></b> (me traigo los datos de mi repositorio remoto. allí se trae una copia del master al directorio y crea la base de datos de todos los cambios historicos en el repo local)
        <br>
        4) repositorio remoto (llego con git push)<br>
        (!!) si quiero actualizar los archivos en mi directorio de trabajo local, tengo que traer con <b> git fetch</b> a mi repositorio local y con <b>git merge</b> a mi directorio de trabajo <br>
        (!!) el comando <b>git pull</b> acciona el fetch+merge
    </p>

    <h1>CLASE 15</h1>
    <p>
        si tengo un archivo que ya estuve commiteando puedo usar <b>git commit -am "descripcion"</b> (hace automateicamente el git add, pero si es un archivo nuevo, no lo va a hacer)
        <h3>Crear nueva rama</h3>
        <p>
            desde la rama en donde estoy (en principio el master) puedo crear una nueva rama. 
            Puedo hacer un <b>git show</b> para ver todos los últimos cambios y también para saber a dónde está apuntando el HEAD (apreto q para salir del visualizador)<br>

            <h4>git branch (nombre que quiero dar a la rama)</h4>
            <p>
                voy a estar creando una nueva rama de trabajo (por ejemplo, hotfix).
                Si hago un <b>git show</b> puedo ver que el HEAD apunta al master y a la nueva rama.
                <br>=><b>git checkout ramaNueva</b> cambio al branch nuevo.
                A partir de acá, todos los cambios que realice, se van a guardar en la nueva rama, sin alterar las otras RAMAS
            </p>

        </p>
    </p>

    <h1>CLASE 16</h1>
    <p>
        MERGE: cuando se fusionan ramas. (!!!)<b>NO OLVIDAR hacer un git commit -am</b> porque si hago un checkout a otra rama, los cambios se pierden(!!!) 
        <br>
        recordar que  el merge se hace desde la rama a la que quiero hacer la fusión de ramas => <b>git checkout master (por ejemplo)</b>
        (!!)si llega a haber un conflicto(dos programadores cambiaron las mismas lineas de codigo y son diferentes), va a haber que solucionarlo a mano, me va a avisar
        
        <h3>git merge nuevaRama</h3>
        <p>se va a abrir VIN porque un merge es un commit a la rama donde estoy haciendo la fusión, para agregar el mensaje</p>
        
        <h4>git branch</h4>
        <p>me va a mostrar qué ramas tengo, y me va a resaltar la rama en la que estoy parada</p>
    </p>
    
    <h1>CLASE 17</h1>
    <p>
        <h2>¿que pasa cuando hay un conflicto al momento de realizar un merge?</h2>
        <p>
            la consola me va a avisar que hay un conflicto y que hasta que no se solucione, no se va a hacer el merge
            <br>la sintaxis para un conflicto es:<br>
            <<<<<<<<<<< HEAD <- indica el conflicto encontrado en la rama actual <br> 
                linea con el conflicto<br>
            ==========<br>
                linea con el conflicto en la rama a fusionar <br>
            >>>>>>>>>> nuevaRama <- indica la rama en donde se encuentra el conflicto <br>
            <br>
            Para solucionarlo, borro esas lineas y elijo con qué opción me quedo<br>
            ya puedo hacer el nuevo commit 
        </p>
    </p>
</body>
___________________________________________________
<h2>Cuarto módulo</h2>
<body>
    <h3>GitHub</h3>
    <strong>es una interfaz visual<br>
       es un servidor de git colaborativo<br>
       es una de las herramientas colaborativas más importante<br>
    </strong>
    <h2>crear repositorio</h2>
    <p>es una buena práctica tener un readme, es un archivo en la raiz del repositorio para que la gente conozca de qué se trata<br>
    <b>RAW</b> me muestra el codigo plano<br>
    <b>BLAME</b> puedo ver los autores de los cambios<br>
    <b>HISTORY</b> es como hacer git log en la consola, me muestra el historial
    <br>

    <h2>git remote add origin (+ link HTTPS del repositorio en github)</h2>
    vamos a agregar un origen remoto para los archivos del directorio local.
    
    <h2>git remote -v</h2>
    el <b>-v</b> parametro para que sea verbal<br>
    me va a indicar el origin para hacer el fetch (traerme cosas) y el origin para hacer el push (subir cosas)

    <h2>git push origin main</h2>
    le estamos diciendo que envíe al origen lo que tengo en master (ahora main). Allí me va a pedir usuario y contraseña del github.
    <br>
    (!!) va a tener un error, porque el remoto tiene datos que no tengo en el local (el archivo readme) => tengo qeu hacer un <b>git pull origin main</b>.
    ALlí va a hacer un error fatal porque hay cosas distintas. Para forzar el merge, tengo que hacer: <br>
    <b> git pull origin main --allow-unrelated-histories</b>. Es un caso aislado, que tiene que ver con la estructura con la que se creean los archivos en github

        <br> =>ahora sí puedo hacer un push.</p>

    <h3>Llaves publicas y privadas</h3>
    <p>
        Cuando tengo un mensaje que no quiero que sea intervenido al enviarlo por internet, tengo que <b>cifrarlo</b>
        Las llaves se crean con un proceso algorítmico que hace que matemáticamente estén vinculadas entre sí
        => mando la llave pública y me quedo con la llave privada. La llave pública puede cifrar el mensaje que se quiere enviar, luego la llave privada puede decifrar ese mensaje 
    </p>

    <h3>Llaves SSH</h3>
    <p>
        es una capa de seguridad mucho más fuerte que el sistema de usuario y contraseña, porque pueden ser hackeadas y permiten entrar al repositorio<br>
        Se crea una llave pública y una privada en el entorno de trabajo, y luego se envía la llave pública a github, por la cual se comenzarán a conectar ( en lugar de https, ahora va a ser ssh)
        => github enviará su llave pública (cifrada) => hay una conexión cifrada de doble camino
    
        <h4>git config --global user.email "un email"</h4>
        sirve para hacer un cambio en el entorno (email)
    
        <h3>crear la llave ssh</h3>
        <p>tengo que estar en el home (~) y uso el comando: <b>ssh-keygen -t rsa -b 4096 -C "miemail" </b>
        allí me va a indicar la RUTA donde se guarda la llave. Luego va a pedir la passphrase (contraseña para la llave). Al finalizar me va 
        a mostrar "la huella" y el "randomart image" para confirmar que se realizó la llave. <br>
        Al terminar, me dirijo a la carpeta para abrir la llave pública y poder pegarla en github<br>

        <h2>Revisar que el servidor de llaves ssh esté prendido</h2>
        <p> sirve para revisar que las llaves estén corriendo y poder hacer la conexión doble a un servidor remoto.
            <b>eval $(ssh-agent -s)</b> y la respuesta sería: Agen pid n°
        </p>

        <h2>Tenemos que agregar en mi entorno la llave privada creada</h2>
        <p>
            <b>ssh-add (+RUTA donde se guarda la llave+nombre de la llave-la de .pub NO, porque estoy agregando la llave privada)</b>
            Al final me va a indicar que la identidad fue añadida.
            Ahora puedo hacer gut pull/git push sin necesidad de usar contraseñas
        </p>
     </p>
        <h3>CLASE 22</h3>
        <p>
            Ingresamos la llave pública a github. => copiamos la llave pública y en settings voy a <b>SSH and GPG keys</b> para pegarla. Me pedirá la contraseña para finalizar
            <br>
            <br>
            en mi repositorio del trabajo, abro la consola para cambiar la url de origin remote, así la paso a ssh
            <h2>git remote set-url origin (pego el url ssh)</h2>
            para verificar los cambios puedo hacer <b>git remote -v</b><br>

            <h2>git pull origin main</h2>
            (orgin se refiere al repositorio remoto) TEngo que traerme la ultima version del servidor. 
            Tenemos que hacer éste comando la primera vez para traer la información que tenemos en el remoto
            => ahora puedo hacer el push (git add, git commit, git push)
        </p>
    </p>
    <h3>CLASE 23: versiones</h3>
    <p>
        <h2>git log --all</h2>
        me muestra todos los commit que haya habido (lo recorro)

        <h2>git log --all --graph</h2>
        hace visual los branch

        <h2> git log --all --graph --decorate --online</h2>
        me muestra toda la historia del proyecto, con los branch visual, pero un poco más comprimido, más fácil de visualizar
        
        <h2><b>ALIAS</b> alias nombreAlias = "git log --....."</h2>
        sirve para renombrar un comando(por ejemplo). Cada profesional crea sus propios alias, quedan guardados en el entorno local

        <h3>TAG</h3>
        <h2> git tag -a nombreTag -m "un mensaje de commit" n°del identificador del commit</h2>
            tengo que tener el hash (identificador) del commit que quiero renombrar. 
            Los tag sirven para renombrar los identificadores del tag. 
            Usualmente por convención se usa v0.1 y demás. 
            Es como hacer un commit,por eso hay que poner un mensaje

        <h2>git show-ref --tags</h2>
        puedo visualizar los commits que están asignados a un tag

        <h2>git tag</h2>
        me muestra todos los tag que tengo<br>

        <h2>git push origin --tags</h2>
        si hago un <b>git status</b> me va a mostrar como que no hay nada para commitear, pero una vez que tengo tag, 
        tendría que mandarlo al repositorio en github, ya que los tag están pensados para el trabajo colaborativo. 
        <br>en branch me van a aparecer los tags.

        <h4>que pasa si quiero eliminar un tag?</h4>
        <h2>git tag -d nombreDelTagAEliminar</h2>
        pero no se borra en github, queda en el marcador.

        <h2>git push origin :refs/tags/nombreDelTagAEliminar</h2>
    </p>

    <h3>CLASE 24: manejo de ramas</h3>
    <p>
        <h4>como agregar la historia de las ramas a github</h4>
        <p>
            tengo que hacer <b>checkout</b> a la rama que quiero subir, luego: <b>git push origin NombreRama</b>
            <br>
            puedo crear más ramas de trabajo. Siempre desde la versión más reciente y principal. puedo hacer <b>git branch nombreDeBranch</b>
            => <b>git push origin nombreRama</b> con eso envío los branch nuevos al repositorio remoto

            <h2>git show-brach</h2>
            muestra las ramas que existen y su historia

            <h2>git show-brach --all</h2>
            idem anterior pero con más detalle

            <h2>gitk</h2>
            me abre un software que muestra todos los branch de forma super visual (para ver estructura y historia completa)



        </p>
    </p>

    <h3>CLASE 25: colaboradores en repositorio remoto</h3>
    <p>
        <h4>Traerme un proyecto desde otro lado</h4>
            <p><h2>git clone (+url del repositorio)</h2>
                con la terminal en el directorio donde quiero que queden los archivos<br>cuando el repositorio es PUBLICO, no pide usuario y contraseña
            </p>
       <h4>Agregar colaboradores al proyecto de github</h4>
            <p>
                desde el repositorio del trabajo, tengo que ir a <b>collaborators</b> y agregar el email o el username de los colaboradores (tienen que ser públicos). Luego, el colaborador tiene que aceptar la invitación
                Ahora los colaboradores pueden pushear desde su repositorio local.
            </p>
    </p>
    </p>
</body>
___________________________________________________
<h2>Quinto módulo</h2>
<body>
    <h3>CLASE 26: flujo de trabajo con pull requests </h3>
    <p>
        <h4>master</h4> es la versión principal, la que se envía al servidor por lo qeu es la versión final
        <h4>servidor de desarrollo o staging</h4> (está justo antes del Master, y lo administra el lider del equipo ) es un entorno lo más similar posible al entorno de producción, es para hacer pruebas sin que afecte al usuario (server de pruebas)
        <h4>feature</h4> es la rama de desarrollo (de entorno local)
        <h4>Pull requests</h4> es un estado intermedio antes de enviar el merge (desde feature) a staging. Una vez aprobado, se hace el merge con el master
        <br>DevOps es el administrador del equipo de trabajo
    </p>

    <h3>CLASE 27: merge a master</h3>
    <p>
        (!!!)siempre tenemos que verificar que todas las ultimas versiones de las ramas son correctas antes de hacer merge en master (main)
        => hago <b>git checkout</b>a cada rama<br>
        <H4>git pull origin nombreRama</H4>
        <p>con este comando me estoy trayendo del repositorio remoto una rama.
            <br>(!!) recordar que en el flujo de trabajo profesional, se trabaja en diferentes ramas, no en master</p>
            
        <h4>git merge nombreRama</h4>
            fusionar ramas (siempre desde el checkout en master-main)
            <br> luego verifico qeu en master-main queda lo qeu precisaba 
   </p>

   <h3>CLASE 28: pull requests</h3>
    <p>
        El pull requests no ejecuta el merge de por sí, pero sirve para describir los detalles, avisos, notas, solicitar revisiones, etc. Es para ordenar el flujo del trabajo
        <br>
        <strong>Comment<br> Aprove: aprobar<br> requests changes: pedir cambios<br> </strong>
    </p>
    <h3>CLASE 29: fork + contribucion [GITHUB]</h3>
    <p>
        si no soy colaborador de un proyecto que me gusta, puedo seguirlo aplicando <b>watch</b> para que me notifique las actualizacione <br>
        <b>estrellita</b> para que lleguen avisos en las conversaciones del proyecto<br>
        <b>hacer fork</b> clonar el proyecto en el estado en que se encuentre, lo voy a tener en mi repositorio de github (pero no puedo crearle ramas,no puede crear tags)
        <br>
        para traermelo a mi disco (y realizar cambios), en mi consola hago <b>git clone (url del proyecto)</b><br>
        ahora voy a tener todos los archivos que forman parte del proyecto, incluyendo el git. Entonces ya puedo editar el código para contribuir en el proyecto open source.
        <br>ahora puedo hacer un git commit -am para <h4></h4>

    </p>
</body>